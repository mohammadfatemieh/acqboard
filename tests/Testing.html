<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Soma Acquisition Board Testing</title>
</head>
<body>
<span style="font-weight: bold; text-decoration: underline;">13 January
2004</span><br style="font-weight: bold; text-decoration: underline;">
<br style="font-weight: bold; text-decoration: underline;">
Okay, this is the assembly and testing log of our (*pray*) final
acquisition board. <br>
<br>
First, some last-minute component shopping:<br>
25LC320/SN-ND EEPROM<br>
SJ5523-0-ND Little rubber feet<br>
399-1091-ND extra bypass caps<br>
399-1096-ND extra bypass caps<br>
67-1253-ND RT &lt; dual LED, red<br>
240-1001-1-ND big analog supply ferrite<br>
240-1008-1-ND smt ferrite bead<br>
RR08P10.0KBCT-ND precision 10k resistors<br>
<br>
Now, testing plans:<br>
<br>
one board, just analog stuff -- no digital<br>
<br>
other board, just digial, no analog.<br>
<br>
<br>
Things to test:<br>
first, digital power supplies<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">14 January
2004</span><br style="font-weight: bold; text-decoration: underline;">
Okay, there's already some code in the "vhdl" subdirectory. Today, I'm
going to create LEDFLASH.vhd which will just flash the leds to let us
know things have booted correctly. <br>
<br>
Baah! After all this work, the vias on the lower right side of the
board didn't connect to the plane! I don't know why -- did I send them
the wrong gerbers? Is this a power plane issue? WTF?<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">9
Februrary 2004</span><br
 style="font-weight: bold; text-decoration: underline;">
After working on the DSP board and getting it + it's accompanying FPGA
code mostly done, we can return our focus to the Acqboard, the
make-or-break component of the system. <br>
<br>
First, Analog power system, which appears to work. <br>
<br>
<br>
Just the output of the AD8221, nothing else. Just A1. <br>
<br>
So, first, just going to solder up an AD8221 and see what we get. <br>
Please note that board 1 Channel A1 is using a 1.0% 475-ohm gain
resistor that measures 476 ohms. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">23
February 2004</span><br
 style="font-weight: bold; text-decoration: underline;">
We get what looks to be 150 uV P-P noise when shorting the inputs of
the A1 AD221 together, at g=104, would translate into &lt; 2 uV input
noise. Strangely, it also looks like we've got a roughly 1.5 uV input
Vos, which seems low. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">16 March
2004</span><br style="font-weight: bold; text-decoration: underline;">
Updated filter design<br>
corrected values to make second-stage 2nd-order LPF bessel with correct
<br>
values<br>
<br>
verified in SPICE<br>
<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">15 April
2004</span><br style="font-weight: bold; text-decoration: underline;">
isolators + shift registers appear to produce correct outputs for at
least a subset of the outputs (i.e. didn't test all)<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">17 April
2004</span><br style="font-weight: bold; text-decoration: underline;">
Discovered that the wrong packaging was used for the EEPROM -- TSSOP
and SOIC packages have different pinouts, and was using the TSSOP
pinout withthe SOIC package. Obviously, this won't work. Solved by
removing IC, soldering CS\ and SO pins together, so all values read
should be zero. This will prevent testing EEPROM reading, writing, on
this version of the acqboard, and will require us having loaden == 0.
Which sucks. But it will still let us measure a great deal of analog
performance. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">23 May 2004</span><br
 style="font-weight: bold; text-decoration: underline;">
Getting ready for tomorrow's testing and assembly. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">24 May 2004</span><br
 style="font-weight: bold; text-decoration: underline;">
Well, look who didn't remember to update the overlays. This really
sucks. So, pending the arrival of the jtag hardware today, we'll test
to make sure we can boot, but that's about it. <br>
<br>
Things wrong on the acqboard:<br>
Overlay text overlays some of the traces. <br>
The connector size for the jtag programmer is wrong. <br>
<br>
But, using 5k Ohm pullups for all pullups and 200 ohm current-limiting
resistors, we have things working. We can connect to the chain, program
the PROM, directly download via the jtag chain to the FPGA. I'd say
this jtag setup was a success. <br>
<br style="font-weight: bold; text-decoration: underline;">
<span style="font-weight: bold; text-decoration: underline;">30 May 2004</span><br
 style="font-weight: bold; text-decoration: underline;">
A short between VSS and GND on the analog side caused this board to be
a loss, but luckily I was able to test the DL capabilities, and sure
enough, the acqboard command interface appears to work correctly.
However, the code is fragile for a number of reasons, including (but
not limited to) <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">3 June 2004</span><br
 style="font-weight: bold; text-decoration: underline;">
Can successfully download, boot, read filters, sample buffer from
EEPROM, acqboard. Turns out there were problems with which exact bytes
we were reading with the loader. Note EEPROM needs you to wait the FULL
5 MS before you try another operation following a write. <br>
<br>
Mode 2 will only use channels 0, 4, and 8 for the sample buffer due to
the way in which we write them. <br>
<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">17 June
2004</span><br style="font-weight: bold; text-decoration: underline;">
So, the new connector size is correct, but the connectors we bought
don't have the correct notch and so in general don't fit. But the
bigger issue was that the solder mask expansion on the connector wasn't
large enough, thus scraping ,and the hole's werent' big enough, hence
drilling. The problem was the VCC and the GND connectors, which needed
jumpers. <br>
<br>
AS of now, things are booting. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">18 June
2004</span><br style="font-weight: bold; text-decoration: underline;">
Wow, mixed up OVDD and OGND pins on ADCs. I suck. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">1 July 2004</span><br
 style="font-weight: bold; text-decoration: underline;">
We can get sine data in raw mode. Now, I'm not sure why everything else
isn't working, and I'm also not sure why we evidently have this damn
jitter, but I'm going to write some analysis code today to look at it. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;"> 2 July
2004</span><br style="font-weight: bold; text-decoration: underline;">
Switching the inputs on the INPUT stage for A &amp; B, such that things
will behave like I expect them to. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">10 July
2004 </span><br style="font-weight: bold; text-decoration: underline;">
Today we begin writing the batch data collection code... we'll see if
this really works!<br>
<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">14 July
2004</span><br style="font-weight: bold; text-decoration: underline;">
<br>
Initial tests show the second harmonic to be down by only 60 dB; I'm
not sure what's causing it, but I've devised a plan to check. We're
switching the test write-up to HTML and we're storing all data in HDF5.
<br>
<br>
The format will be as follows. We're doing all of this with <a
 href="http://pytables.sf.net">pytables</a> as a really nice interface.
Lovely, though, it appears pytables doesn't support storing of arrays
as attributes (metadata). So we use... strings!!!<br>
<br>
All files will have a "notes". We can also attach&nbsp; notes to each
channel. <br>
<br>
each file will have a channelname (A1, AC, etc) off the root, which
will be the data for that channel. In general, then, a file might have:<br>
<br>
/A1/sine/run0 <br>
/A1/sine/run1 <br>
/A2/noise/run0<br>
/A2/noise/run1<br>
/BC/IMD/run0<br>
/B1/real/run0<br>
<br>
The root will always have a "notes" field, as well as <br>
<br>
now, each "run" has the necessary metadata to fully describe both the
state of the acqboard and the function generator:<br>
Function generator:<br>
<br>
amplitude tuple of 2 floats (for IMD)<br>
frequency tuple of 2 floats (for IMD)<br>
mode (any of the noted modes, 0=sin, 1=sqr 2=white, 3=pink, 4=2tone)<br>
offset (float) <br>
<br>
Aqboard:<br>
mode (int)<br>
inchanA<br>
inchanB<br>
gains = tuple of 10 ints, as string<br>
hpfs = tuple of 10 ints, as string<br>
rawchan : raw channel<br>
<br>
<br>
Now, how to organize the code? <br>
<br>
Ideally, we do:<br>
create acqstate object<br>
create fstate object<br>
perform run, take data<br>
save as "location", acqstate, fstate<br>
<br>
really, all this code should live under "analysis"<br>
<br>
<br>
"test" handles interfacing with all the components and retrieving the
results<br>
<br>
"run" will handle putting the data in the relevant format for hdf5,
saving the results, etc. <br>
<br>
How to organize "runs"? what we really want is something that will just
DTRT given an acqstate and a function state, and a number of samples. <br>
<br>
So, a "run" could be a hdf5 wrap of a test. That wouldn't suck. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">15 July
2004</span><br style="font-weight: bold; text-decoration: underline;">
First, we want to run the pure sine test, using a coherently sampled
sine wave. Early tests suggest that we're not getting quite what we'd
hope for... so we've created this notion of "sets" of runs. <br>
<br>
<span style="font-weight: bold; color: rgb(0, 0, 102);">Generated
results/20040715/simplerun.h5 sweeping through gains, freqencies on the
first ADC, both inputs. </span><br
 style="font-weight: bold; color: rgb(0, 0, 102);">
<br>
<img style="width: 1200px; height: 900px;" alt=""
 src="results/20040715/simplerun.sine.g100.g0.a100.png"><br>
The above is the result of <span style="font-weight: bold;">channel A1
being fed a 207 Hz coherently-sampled sine, using a gain of 1 with
DC-based HPF</span>.&nbsp; Similarly, <br>
<br>
This isnt' the best way of visualizing this, I think I'm going to write
the "show" code to write parameters...<br>
<br>
Anywho, the results look similar across the board -- 76-77 dB of actual
SNR. <br>
<br>
Now, let's look at raw noise. <br>
<br>
The noise data is truly bizzare. All of what follows is from
rtinoise.h5. We get as-expected noise distributions for low gains on
channel A1:<br>
<br>
<img style="width: 600px; height: 450px;" alt=""
 src="results/20040715/rtinoise.A1.g100.png"><img
 style="width: 600px; height: 450px;" alt=""
 src="results/20040715/rtinoise.A2.g100.png"><img
 style="width: 600px; height: 450px;" alt=""
 src="results/20040715/rtinoise.A1.g10000.png"><img
 style="width: 600px; height: 450px;" alt=""
 src="results/20040715/rtinoise.A2.g10000.png"><br>
<br>
So, visually, the distributions for the high-gain outputs looks really
poor. I have no idea where the spiking is coming from, although there
are a few candidates:<br>
<ul>
  <li>external environment noise. Okay, maybe, but why the unusual
distribution? The spikes appear truly random in time, but clearly
quantized in amplitude. <br>
  </li>
  <li>They could potentially be bit-errors in the readout. But they
show up in powers of two. For example:</li>
</ul>
<div style="text-align: center;"><img
 style="width: 1200px; height: 900px;" alt=""
 src="results/20040715/rtinoise.A2.g10000.ranges.png"><br>
</div>
<br>
So hmm, that doesn't look suspicious?? But even if you assume errors in
bits 7 &amp; 8, WHY those bits and WHY only at high gains? This does
not make sense, at all! Perhaps the errors only manifest themselves
when the input is in that region? It can't be an 8b/10b related issue,
because that's a byte-encoding. The input-range hypothesis can be
tested. <br>
<br>
So, could we potentially have an error -any- place we have a 16-bit
interface? <br>
<br>
Wow, looking back, this is the histogram for the diff for the A1
channel with freq 1 at g=100 with 100% amplitude:<br>
<br>
<div style="text-align: center;"><img
 style="width: 1200px; height: 900px;" alt=""
 src="results/20040715/simplerun.A1.sine.g100.a100.hist-of-diff.png"><br>
<div style="text-align: left;">The red bars are at +-256 and +/- 512.
Wow, wow, Wow. <br>
<br>
An interesting idea would be to see what we can get out of the
simulated output mode. Inital inspections suggest nothing; maybe we
only get errors for certain ranges? Let's program the sample buffer for
a 0-255 sweep...<br>
<br>
<br>
<br>
Well, after investigating a bit more, there is some sever strangeness
occuring with the sample buffer mode. I don't quite understand what's
going on. In any case, that's a day!!<br>
<br>
</div>
</div>
<br>
<span style="font-weight: bold; text-decoration: underline;">16 July
2004</span><br style="font-weight: bold; text-decoration: underline;">
Now, it seems that the sample input is having problems -- let's see
what's up!<br>
<br>
THE OUTPUT VALUES GO FROM 0 to 248 BECAUSE IT IS DOWNSAMPLING THE
OUTPUT! YOU FOOL!<br>
<br>
When we run with a random sequence of inputs, we don't have problems --
we read out a reasonably random range between -32768 and 32768, without
error. <br>
<br>
The thing is, this just -really- looks like an ADC problem -- I can't
think of anything else it might be!<br>
<br>
Channel modifications<br>
<ul>
  <li>A3 has connected the output of the inamp to the input of the AA
filter<br>
  </li>
  <li>A4 is shorts the input of the AA filter to nearby ground</li>
</ul>
So, we're still getting the noise problems (see
results/date/rtinoise.modified), so we took the board and resoldered
around the ADC. One pin on the A1/2 ADC wasn't soldered correctly. <br>
<br>
So, having soldered, now we'll take more data. And we get outputs (from
results/data/rtinoise.modified.post-solder) like:<br>
<br>
<img style="width: 1200px; height: 900px;" alt=""
 src="results/20040716/rtinoise.modified.post-solder.A3.g100.png"><br>
<br>
Which, umm, is crap. Look at that!!! Smilarly, for A1:<br>
<img style="width: 1200px; height: 900px;" alt=""
 src="results/20040716/rtinoise.modified.post-solder.A1.g10000.png"><br>
<br>
So, here we are, the same place we were yesterday, but with more
inputs. I really have no freaking idea what to do. <br>
<br>
While out at dinner, came up with a few small ideas. First, per-bit
statistics: mean, variance, distribution.<br>
<br>
Bit statistics appear to tell us nothing unusual. But look at this:<br>
<br>
<img style="width: 512px; height: 384px;" alt=""
 src="results/20040716/a2.g10000.diff.hist.png">This is a histogram of
the differences from the full record of A2. Wow, it sure does look
like, say, 255 is getting randomly added or subtracted there!! But
where? where is this coming from? ADC errors? <br>
<br>
Even on the sine data! Here's yesterday's sine recording, but a plot of
the diff() of the signal!<br>
<br>
<img style="width: 1200px; height: 900px;" alt=""
 src="results/20040716/sinediffs.png"><br>
<br>
Again, how horrible!! We're running out of potential candidates. Now,
it -could- be a problem internal to the FPGA, but that's just so
unlikely that I'm not even going to consider it. Although the above
suggests either an -amplitude- or -phase- correlation. But rather than
hyper-analyzing it, let's figure out our timings again. The only
plausable candidate at the moment is the isolators, although I'll be
damned if I can figure out how they'd cause -this- sort of error. <br>
<br>
Measuring on the scope, a SDOUT bit width is ~50 ns, which, when you
sum the worst-case propagation times for the various components in the
chain, "might" be an issue. Except that measuring the propagation
delays of various bits of the system with the scope suggests that we're
really looking at a P(delay) of, oh, 10 ns -total-. The ADC seems to be
pretty good at sticking with 2 ns. At the same time, the sorts of
single-bit errors (why always the same place) suggests a real
fundamental problem. <br>
<br>
On a slight hunch (yikes!) I'm going to try and sample one cycle
earlier. <br>
<br>
Umm, that appears to have made things worse! Sampling one cycle sooner
(INCE one cycle ahead) gives... <br>
<img style="width: 1200px; height: 900px;" alt=""
 src="results/20040716/early-cycle.sinediffs.png"><br>
<br>
At least this strongly suggests what the real problem is. The downside
is how to work around it -- how can we possibly hope to speed things up
at all? <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">17 July
2004</span><br style="font-weight: bold; text-decoration: underline;">
<br>
Okay, new day, new calculations. Currently we allow for 139 ticks (2.17
us) between CONVST assertion and when we start reading. That's way too
long. Really, we could go to 112 ticks and be fine. Maybe even 120 to
compensate for propagation delay. Alas, even after adding the extra
cycle, we're still getting the same errors, although perhaps the DL to
the board didn't go correctly? <br>
<br>
So we reverted to the original input code and made a simulation of the
inputs.. no problems. Ass. Even when we have raw mode disable the
offsets, we're still getting the errors. <br>
<br>
Simulations seem to suggest that we can endure aggregate propagation
delays of 44 ns between when we actually output SCLK and when we get
the result. <br>
<br>
There appears to be a dependence on the amplitude here. <br>
<br>
Rapidly running out of ideas, fish found some unsoldered bypass caps
and soldered them, with no result. Similarly, I've changed the ADCIN
inputs on the FPGA to use internal pull-downs. Again, no luck. What
about a pull-down on the analog side of the IO converter? Still no
difference. At this point, I'm willing to say that the sticky bits
hypothesis has no real luck of going anywhere. <br>
<br>
Okay, there are two types of problems: those I can fix and those I
can't. Those I can't fix fall into<br>
<ul>
  <li>Something wrong with the ADC:</li>
  <ul>
    <li>it just sucks, and you're SOL</li>
    <li>There's some problem related to the reference</li>
    <li>there's some problem related to the internal converter</li>
    <li>there's some problem related to the input</li>
  </ul>
  <li>Something's wrong with the GMR Isolators</li>
  <ul>
    <li>You just can't drive them this way, i.e. they get stuck
sometimes and there's just nothing you can do about it</li>
  </ul>
</ul>
<br>
Moving INEN to the SCLKH1 line hasn't accomplished anything... I feel
like I'm going about this all wrong... <br>
<br>
<br>
When I intentionally read too few bits, I get the following from
channel A1:<br>
<img style="width: 600px; height: 450px;" alt=""
 src="results/20040717/intentional-bit-error.png"><br>
This, while pretty, is -not- what we're getting, although it -does-
look somewhat familiar. A2 looks near-identical. Frustration, coupled
with near-insanity, is forcing me to ditch the output registers, and
just focus on a simple interface with no output registers. Yea, we
could have glitches on the output (although how likely is this?) but
... it simplifies things tremendously. <br>
<br>
<table style="text-align: left; width: 255px; height: 74px;" border="1"
 cellpadding="2" cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">SCLK out of FPGA<br>
      </td>
      <td style="vertical-align: top;">4 ns<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">cross 1st ISO<br>
      </td>
      <td style="vertical-align: top;">15 ns<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SCLK to SDOUT<br>
      </td>
      <td style="vertical-align: top;">18 ns<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">cross second ISO <br>
      </td>
      <td style="vertical-align: top;">18 ns<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">into FPGA<br>
      </td>
      <td style="vertical-align: top;">4 ns<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">setup<br>
      </td>
      <td style="vertical-align: top;">2 ns<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-weight: bold;">TOTAL<br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">61 ns<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
For comparison, the full 4 cycle setup will take... 62.5 ns!!!<br>
<br>
WEll, I re-wrote the input code for the ADCs, taking out the pipelining
(but also removing some of the registering -- whatever) and I'm excited
that I can hopefully eliminate it as a potential issue. But still...
same errors. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">18 July
2004</span><br style="font-weight: bold; text-decoration: underline;">
Wow, rapidly running out of ideas. The fixed ADC code hasn't helped
any. I still get the quantization, even when I directly connect the
unbalanced output of the function generator into the input of the ADC. <br>
<br>
Watching the output on the scope, we can see that all output values are
being set. This can be seen by triggering off of CS and taking the
average; any stuck value would be apparent. We see the same thing on
the other side of the FPGA. Even having the FPGA latch bits suggests --
there's no bit sticking!<br>
<br>
<br>
In an attempt to re-evaluate where we are, I'm going to re-acquire a
sample. <br>
<br>
Indeed, results/today/sineagain.h5 shows A1.g100.f1.a100 to be nearly
the same as above, with the same problems. Let's look at the hist of
the diffs...<br>
<br>
<img style="width: 600px; height: 450px;" alt=""
 src="results/20040718/a1.g100.f0.a100.diff-hist.png"><img
 style="width: 600px; height: 450px;" alt=""
 src="results/20040718/a1.g100.f0.a100.diff-hist-zoom.png"><br>
<br>
Now, the diff histogram is similar to earlier (pre- New Input.vhd)
data, but the odd multiples of 8 never showing up as diffs is totally
an error. <br>
<img style="width: 600px; height: 450px;" alt=""
 src="results/20040718/sineagain.a1.mod16.png"><br>
Interestingly, A3 &amp; A4 don't have this problem -- maybe it has to
do with the pull-up resistor? Cutting resistor and rerunning...<br>
<br>
Nope, still the same problem. Here's a bit-plot:<br>
<br>
<br>
<br>
<br>
<img style="width: 1200px; height: 900px;" alt=""
 src="results/20040718/samebits.png"><br>
This is for A1, g=100, data taken from sine_noresistor.h5. Both A1 and
A2 exhibit this problem, but A3 does not. But <span
 style="font-style: italic;">the shifted outputs of the ADC (as
measured by averaging) don't appear to have this problem!<span
 style="font-weight: bold;"> </span></span>In fact, both bits 2 and 3
appear to be unaffected. This is now super-duper odd, esp. since it
only affects ADC1. <br>
<br>
Went down, made timing constraints a bit tighter on CLK, and switched
all input voltage levels to LVTTL. Didn't help with -either- problem;
A1/2 still shows identical bits 2 &amp; 3; both ADCs 1 &amp; 2 still
have 256 problems. <br>
<br>
<br>
Now we get desperate: we're going to trash the input stage. Make it as
simple as possible; all we'll get out is the input of chan 0 <br>
<br>
<span style="font-weight: bold;">Then I tried to totally rewrite the
input code</span> to just do a quick hack, but I -still- get the 256
errors. BUT that fixed the 2/3 bit stick error. Grrr. <br>
<br>
This does not make sense. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">19 July
2004</span><br style="font-weight: bold; text-decoration: underline;">
<br>
Okay, I want to sample this, and I want to trust the results. I wanted
to write an interface to the oscope, but both it and the 6.111 Lab
analyzers have too shallow of memory depth. <br>
<br>
The people at analog devices are being helpful, and I'm preparing some
code histograms for them. <br>
<br>
<br>
20 July 2004<br>
Sent things to Analog, waiting for response. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">13 August
2004</span><br style="font-weight: bold; text-decoration: underline;">
<br>
Many responses from analog engineer; in particular, we'll want to
buffer the reference input to each ADC. To test and see if indeed the
reference was the problem, I desoldered the resistors to REF pins on
the ADCs, thus disconnecting all ADCs from the input reference; I then
shorted across this resistor for ADC1&nbsp; and took data on A1. <br>
<br>
<img style="width: 600px; height: 450px;" alt=""
 src="results/20040813/A1.noADCres.ADC1shorted.png"><br>
This is really depressing. Chris suggested that I consider the problem
is&nbsp; still the FPGA, and look at the converter output bits using a
simple precision DC source. We really haven't tried this option, and
it's worth a shot. I just need a precision OA and some resistors...<br>
<br style="font-weight: bold; text-decoration: underline;">
<span style="font-weight: bold; text-decoration: underline;">15 August
2004</span><br>
I built the precision DC source, although I may have subsequently burnt
it out. No bother, though, because ADC4 appears to have difficulty
reading even bits:<br>
<br>
<img style="width: 600px; height: 450px;" alt=""
 src="results/20040815/ADC4.DCin.png"><br>
What to do, what to do... <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">16 August
2004</span><br style="font-weight: bold; text-decoration: underline;">
<br>
Okay, accepting the fact that we obviously have some digital signal
integrity problems here, how can we rectify these? <br>
<br>
Well, my first zeroth-order guess as to the problem is that it's some
sort of timing-related error in the FPGA. While I know that EVERY
SINGLE FPGA-based error assumption I've ever made has turned out to be
really really wrong, I'm going to still try to replace the input side. <br>
<br>
Having lobotomized the input stage, we no longer have the
no-even-values error. <span style="font-weight: bold;">This means that
the digital input&nbsp; portion of the FPGA was at least partly
responsible</span>. So, we'll have to fix that. <br>
<br>
&nbsp;But, that said, for some values of the ADC input, we get a really
nice output. For other values, generated from our DC source, we get:<br>
<br>
<img style="width: 600px; height: 450px;" alt=""
 src="results/20040816/ADC4.DCin.badhist.png"><img
 style="width: 600px; height: 450px;" alt=""
 src="results/20040816/ADC4.DCin.badhist.diff.png"><br>
<br>
With the actual value histogram on the left and the diff histogram on
the right. <br>
When we take the output of the ADC, in averaging mode, for channel B
(thus the first 16 bits we see there) we get<br>
<br>
<img style="width: 640px; height: 480px;" alt=""
 src="results/20040816/scope%20out%20for%20bad%20histogram.averages.png"
 align="left">Note
then that the low bits are -all- being triggered; this suggests some
really fundamental signal integrity problems. <br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
At the same time, the following is the histogram from the input shorted
to ground:<br>
<br>
<img style="width: 600px; height: 450px;" alt=""
 src="results/20040816/short-to-ground.hist.png"><br>
<br>
This really suggests the ADC is sucking for some number of reasons. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">24
September 2004: The Analog Test Board</span><br
 style="font-weight: bold; text-decoration: underline;">
The availability of the awesome Audio Precision ATS-2 for measurement
has prompted me to build an analog test board, which will let me
measure all aspects of the analog performance, including a comparison
of three different op-amp AA filter designs. <br>
<br>
We've built the discrete AA filters using a 4-stage (8 pole) MFB
architecture, and used TI's FilterPro to select component values. Now,
I'm a bit confused by this FilterPro program, as it renders different
stages differently, but it claims to work well. Ha. In any case, the
Bessel MFB 8-pole with a 16.5 kHz cuttoff and a 10k seed resistor (with
E24 resistors and E6 caps) gives us -95 dB at 128 kHz while having only
-1.1 dB at 10 kHz. Booya. <br>
<br>
In some sort of sick conspiracy, I designed the board with the
AD8513ARU instead of the AR, and now I get to wait for a shipment of
them from digikey. Wow, I'm sure glad money isn't much of a constraint.
<br>
<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">26
September 2004 : Analog test board results via ATS-2</span><br
 style="font-weight: bold; text-decoration: underline;">
The output of the ATS-2 is interesting; it is a fantastically complex
instrument, or moreso, it does some complex DSP. Really, all I want is
something that costs $10k and takes in / puts out the desired signal
leves so I can do my own fucking DSP. But whatever.<br>
<br>
The device calculates THD via an FFT (by summing the harmonics) and a
THD+N by the standard notch filter approach. This is important to
recognize when trying to calculate and compare these sorts of numbers. <br>
<br>
I've buillt what I can manage on the test board; in particular I have
the two working AA filters, as well as an input stage and a PGA stage.
It is frustrating, because some components (like the PGA) have THD+N
measurements where the THD+N number is a decreasing function of
frequency. This is extra odd because the low frequency components
should distort less. <br>
<br>
<span style="font-style: italic;"></span><span
 style="font-weight: bold; text-decoration: underline;">1 October 2004:
Wow, it's already october</span><br
 style="font-weight: bold; text-decoration: underline;">
Initial data, whee! The first thing we noticed was that the results are
really poor unless we put a 0.1uF cap at the input to the voltage
offset op-amp input. Then things suck a lot less. <br>
<br>
<table style="text-align: left; width: 100%;" border="1" cellpadding="2"
 cellspacing="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">Test<br>
      </td>
      <td style="vertical-align: top;"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Frequency Response, via 4.097Vpp
input<br>
      </td>
      <td style="vertical-align: top;"><img
 style="width: 600px; height: 450px;" alt=""
 src="results/20041001/frequencyresponse.png"><br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">THD+N, using 4.097 Vpp input<br>
      </td>
      <td style="vertical-align: top;"><img
 style="width: 600px; height: 450px;" alt=""
 src="file:///home/jonas/soma/developer/acqboard/tests/results/20041001/thd+n.png">
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">Harmonic Distortion (sum of
harmonics 2+3)<br>
      </td>
      <td style="vertical-align: top;"><img
 style="width: 600px; height: 450px;" alt=""
 src="results/20041001/harmonicdistortion.png"><br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
<br>
<br>
I think pretty much across the board the AD8028 is the superior choice.
<br>
<br>
Now, there are other measurements we could make. But at the moment, the
most depressing fact is the horrible performance of the HPF. The THD+N
is like -70dB. So sad. The graph below is -without- any filter, i.e.
mux in position zero. <br>
<img style="width: 600px; height: 450px;" alt=""
 src="results/20041001/thd+n.hpf.png"><br>
<br>
Horrible!<br>
<br>
The other parts look okay, for example the PGA (g=1) THD+N:<br>
<img style="width: 600px; height: 450px;" alt=""
 src="results/20041001/thd+n.pga.g1.png"><br>
<br>
<span style="font-weight: bold; text-decoration: underline;">3 October
2004:</span><br style="font-weight: bold; text-decoration: underline;">
Okay, so the new goal is to use the AD8513 for the filter, it's quite
nice. I wish there was some way I could take the 3rd amp and use one as
the PGA, but it's going to be totally different signal ranges. So I
don't think that's the best idea; we'll also want something with lower
noise. <br>
<br>
ADG619 looks to be the ideal&nbsp; switch, but the input resistance on
the PGA is only 1k at g&gt;5. That's a bit concerning from the THD+N
standpoint, due to the problems with the mux's nonlinearities. So I
want to test two designs: <br>
<br>
Thus we're giving birth to Analog Test Board 2:<br>
<ul>
  <li>In-amp high pass configuration A, using a HPF coupled to the ref
pin:</li>
  <ul>
    <li>SPDT or DPDT mux</li>
    <li>single or double pole? <br>
    </li>
  </ul>
  <li>In-amp high pass configuration B, using a separate HPF consisting
of a single OA and the HPF being a double-pole, with the SPST switching
between OA output and unfiltered output</li>
</ul>
The parts we're going to use include the ADG619. Now, it's interesting
to note that the op amp for the HPF doesn't need to be a jfet input, so
I might use the OP1177, which looks to be a really solid part. <br>
<br>
In any of these HPF cases, I worry a lot about the impact of the delay.
I am abandoning my 2-pole connected to the op-amp approach because of
challenges with filter design. And I suck. <br>
<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">15
November 2004:</span><br
 style="font-weight: bold; text-decoration: underline;">
<br>
High pass filter configuration and analog test board 2. How to minimize
group delay? <br>
<br>
For a 1-pole bessel HPF with cutoff = 300 Hz, 8 Hz is down by 30 dB and
group delay in passband is 200 uS<br>
2 pole bessel HPF with cutoff = 300 Hz, 8Hz is down by 59 dB, and group
delay in passband is 500 uS<br>
<br>
A 1 mV theta will be reduced by a factor of 30 at 30 dB, i.e. 30 uV,
which is pretty good. We can also do post-filtering. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">18
November 2004: Analog test board 2 results</span><br
 style="font-weight: bold; text-decoration: underline;">
This is the <span style="font-weight: bold;">no-switch</span> test,
measuring bipolar 80 mVpp input into the XLR input, through the g=100
IA, and out of the HPF. <br>
<br>
<img alt="" src="results/20041118/frequencyresponse.nosw.png"
 style="width: 600px; height: 450px;"><img alt=""
 src="results/20041118/thdn.nosw.png"
 style="width: 600px; height: 450px;"><br>
<br>
This is exactly what we'd expect, with the ~20 dB/decade fall off of a
single pole filter. The THD+N measurements suffer because of the manner
in which we are measuring: at each frequency, we are comparing the
output power to the relative noise and input power. The highpass filter
obviously reduces the power in the stopband, thus our THD+N
measurements look like crap. Still, it's what you'd expect. <br>
<br>
Now, the THD+N measurements <span style="font-weight: bold;">for the
single-pole version with the switch</span>:<br>
<br>
<img alt="" src="results/20041118/thdn.switch.disabled.png"
 style="width: 600px; height: 450px;"><img alt=""
 src="results/20041118/thdn.switch.enabled.png"
 style="width: 600px; height: 450px;"><br>
The left is with the filter enabled, the right is with it disabled.
It's hard to understand how wonderful this performance is. However, we
compare it to the performance of the lone analog in-amp (using the
channel for the 2pole filter on analogtestboard2, but without having
soldered any of the parts downstream from the IA) <span
 style="font-weight: bold;">below</span>:<br>
<img alt="" src="results/20041118/thdn.justIA.png"
 style="width: 600px; height: 450px;"><br>
This is by far a vote in favor of the current filter/switch
design.&nbsp; <br>
<br>
Next, linearity for the four:<br>
<img alt="" src="results/20041118/alin.png"
 style="width: 1200px; height: 900px;"><br>
<br>
That's really exciting, too, if you remember that the crappy
performance at the &lt;100uV range is most likely due to noise
corrupting the measurements. This is "normalized gain", i.e. we removed
the mean gain. <br>
<br>
<br>
<span style="font-weight: bold;">Now, the whole channel, from IA to
post-AA (for analog test board 2, of course): </span><br>
<img alt="" src="results/20041118/thdn.wholechan.png"
 style="width: 600px; height: 450px;"><br>
That's with the HPF disabled and the PGAg=1. That's spectacular. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">21
November 2004 : </span><span style="font-weight: bold;">still problems<br>
<span style="font-weight: bold;"><span style="font-weight: bold;"><span
 style="font-weight: bold;">one problem: </span></span></span></span>continuous
input channels have no way of getting unfiltered input from IAs using
this feedback approach. 300<span style="font-weight: bold;"><span
 style="font-weight: bold;"><span style="font-weight: bold;"><span
 style="font-weight: bold;"></span></span></span><br
 style="font-weight: bold; text-decoration: underline;">
</span><br>
So, I modified the channel with the 2-pole HPF to have only a single
pole (RC) HPF centered at 300 Hz. The THD+N measurements (again, 40
mVpp input, HPF off) are: <br>
<img alt="" src="results/20041121/thdn.singlepole.png"
 style="width: 1200px; height: 900px;"><br>
Again, that looks great. Amplitude linearity for this configuration is
between 39.98 and 40.015 dB between 100u and 40m at 1khz. Similar
linearity measures are obtained for different frequencies. <br>
<br>
For cost, 397.69 for initial design, <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">8 December
2004</span><br style="font-weight: bold; text-decoration: underline;">
Soldered up the initial board; I was dumb and forgot the data lines on
the FPGA. Currently we have DC inputs. Wow, there's like a 5% sine wave
on the input that looks really awful, in raw mode. The only potential
saving grace is that these are iso-loop-related signal integrity
problems, because when I press with my finger on the ISOloop for ADC1
that carries SDIN I get random bit errors. <br>
<br>
There appears to be a propagation delay across the isoloops of 8 ns in
each direction. <br>
<br>
Attempting giant cap at ref input, still no progress. <br>
<br>
When I look at the signals, we obviously see a lot of really bad
ringing in the digital signals. I wonder if I should be doing some sort
of termination (etc) to minimize negative effects of this? <br>
<br>
The thing is, during the conversion process that side of the board
should be dead fucking quiet. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">9 December
2004</span><br style="font-weight: bold; text-decoration: underline;">
<br>
The conclusion from last night, then, means that whatever problems that
we're seeing are only on the ADC side. This means that we need to screw
around a bit with ground plane issues. <br>
<br>
Things we know we want to fix:<br>
<ul>
  <li><br>
  </li>
  <li>pull ups/downs for the digital inputs to the isoloop<br>
  </li>
  <li>source&nbsp; impedance matching for the outputs to reduce visible
ringing</li>
  <li>extra caps (47 uF?) on the output of the OAs that handle the
reference input</li>
</ul>
<br>
Then, our two new strategies for power will be:<br>
<ul>
  <li>localized DVDD, i.e. one LPF for each component that wants/needs
it</li>
</ul>
<br>
<span style="font-weight: bold; text-decoration: underline;">17
December 2004</span><br>
Following what would be an entertaining comedy of errors if it were
someone elses project, we now have 3 (!) v4.1 acqboards in front of us.
The first step will be soldering up the digital subsystem. <br>
<br>
Enclosure front hole is too small for 103311-5 connectors; I'm not sure
if these were the exact ones we were supposed to get. Front hole is:
1340mil x 251 mil, 240 mil from top. Connector was wrong in enclosure
model; is actually 350 mil high. <br>
<br>
Fuck; jtag interface is totally wrong. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">15 January
2005</span><br style="font-weight: bold; text-decoration: underline;">
The bit shifting of the LSBs for the individual-DVDD planes is better,
although it still seems as if the 2 LSBs are excessively noisy; now we
just have to see what our actual output looks like.<br>
<br>
Actually, strike that; the 4 LSBs on this channel are quite noisy. That
sucks. But the lowpass capacitor for the input makes things -worse-.<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">20 January
2005</span><br style="font-weight: bold; text-decoration: underline;">
Initial analysis suggested that, indeed, we only had two LSBs worth of
noise, but we're back to exactly the same problems we had before, in
previous iterations of the board. <br>
<br>
These measures definitly look better (more concrete data tomorrow) but
most importantly, we're getting a logic analyzer to help us pull data
right off the raw ADC instead of having to rely on our complete data
processing stream, whcih involves:<br>
<br>
SPI -&gt; isoloop -&gt; FPGA -&gt; optical 8b/10b -&gt; main fpga -&gt;
FIFO FPGA -&gt; FIFO ram -&gt; FIFO FPGA -&gt; main FPGA -&gt; GPIF io
on FX2 -&gt; USB -&gt; master -&gt; domain socket -&gt; client app<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">21 January
2005</span><br style="font-weight: bold; text-decoration: underline;">
<span style="font-weight: bold;"><span style="font-style: italic;">WOOHOOOOO!
</span></span>Using<span style="font-style: italic;"></span> the logic
analyzer, we can download raw digital output from the ADC side, and we
get:<br>
<br>
<img alt="" src="results/20050121/sine-from-analyzer.png"
 style="width: 1200px; height: 900px;"><br>
Wow, although this begs the interesting question -where the hell is the
problem-? <br>
<br>
The code to read this is under
acqboard/tests/results/20050121/ADCreading.py<br>
<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">22 January
2005</span><br style="font-weight: bold; text-decoration: underline;">
We are almost certainly dealing with a problem with the serial
interface, due to timing concerns, propagation delays, and the isoloop
converters. We are going to try and use the "simple" test to interface
witht he ADC. <br>
<br>
10:00 pm We have changed the input side to use a shorter CS and use
4-tick CLK pulses, and eventually will simplify the entire input
subsystem considerably. At the moment, however:<br>
<ul>
  <li>we can read the serial output from the DIGITAL side of the
isoloop isolators, meaning that we're doing something right</li>
  <li>More importantly, we created a simple serial debugging module and
used the serial PGA programming pins to connect it to the logic
analyzer; the output is PERFECT, while the output from the
protoboard/usb still shows the same bugs. This gets more and more
confusing each time</li>
</ul>
<br>
Bug source candidates: <br>
<ul>
  <li>inside of the FPGA on the acqboard<br>
  </li>
  <li>inside of the protoboard FPGA, or any other place on the
protoboard</li>
</ul>
To help narrow this down, we are going to attach the same serial
debugging code to the FPGA on the protoboard; there's some mild concern
because that code hasn't been touched in years, but oh well. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">24 January
2005</span><br style="font-weight: bold; text-decoration: underline;">
So close! The corruption is somehow happening <span
 style="font-weight: bold;">inside</span> of the FPGA; we can see this
via tying the input to the 8b/10b encoder on FiberTX inside the
acqboard FPGA to the debugging output. <br>
<br>
How frustrating and confusing. This rules out, or at least
substantially reduces the probability of, the problem being in:<br>
<ul>
  <li>protointerface board</li>
  <li>8b/10b encoder being too slow</li>
</ul>
At this point, we can be sure without a doubt that the problem exists
in the FPGA. This means that either we have strange higher-order
hardware problems inside of the FPGA, or that our unit tests have
failed. Given that the acqboard code is old and busted, and has yet to
be converted to new documentation nor be updated for the new testbench
organization, I'm going to start refactoring and updating its
documentation today. <br>
<br>
<span style="text-decoration: underline;"><span
 style="font-weight: bold;">27 January 2005</span></span><br>
Following the re-write of input, raw, and fiberTX, we now have a system
that WORKS! Yes, you heard that right, from acqboard reader we have:<br>
<br>
<img alt="" src="results/20050127/sine.png"
 style="width: 1200px; height: 900px;"><br>
Strangely, to get this we had to adjust various offsets in the
acqboard_reader. Acqscope gives:<br>
<br>
<img alt="" src="results/20050127/success.png"
 style="width: 800px; height: 600px;"><br>
<br>
Which is again spectacular. <br>
<br>
I'm going to commit all of this; tomorrow, some more unit testing, then
we move towards performance testing! <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">29 January
2005: Organization of test suite code</span><br
 style="font-weight: bold; text-decoration: underline;">
<br>
For performance analysis in raw mode we will organize data as:<br>
<br>
/CHANNAME/INPUTTYPE/RUNNAME<br>
<br>
where channame is A1-AC, B1-BC, <br>
<br>
input type is the input type, i.e. <br>
<ul>
  <li>noise : white / pink noise inputs</li>
  <li>square : square wave</li>
  <ul>
    <li>Fields:</li>
    <ul>
      <li>Frequency <br>
      </li>
      <li>source VPP</li>
    </ul>
    <li><br>
    </li>
  </ul>
  <li>sines : a set of sine waves, nominally a sweep</li>
  <ul>
    <li>Fields<br>
    </li>
    <ul>
      <li>frequency (float) :<br>
      </li>
      <li>source vpp : vpp of ADC</li>
      <li>data</li>
    </ul>
    <li>Table (run) metadata</li>
    <ul>
      <li>gain</li>
      <li>filter settings</li>
    </ul>
  </ul>
  <li>IMD</li>
  <ul>
    <li>[to implement]<br>
    </li>
  </ul>
</ul>
<br>
We'll write some python code to wrap this up nicely:<br>
rawf = RawHDF5("filename")<br>
rafA1 = rawf.openChannel("A1")<br>
sinerun = rafA1.addSineRun("Name", gain, filter, "note")<br>
sinerun.append(frequency, vpp, datavect)<br>
<br>
<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">30 January
2005</span><br style="font-weight: bold; text-decoration: underline;">
<br>
Even with a raw input (i.e. no anti-aliasing filter) I still can't get
coherent sampling working. This is a bit troubling, because it suggests
that there's something wrong someplace. I've tried with both the SRS
360 and the ATS-2 to generate the inputs, all with no luck; we still
get the skirt around the fundamental. <br>
<br>
Tomorrow we will begin THD+N measurements at a variety of frequencies
in an attempt to characterize performance. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">1 February
2005</span><br style="font-weight: bold; text-decoration: underline;">
<br>
sr = Raw.SineRun(rawh5file)<br>
sr.name = "Name"<br>
sr.channel = "A1"<br>
sr.range =&nbsp; logspace(log10(20), log10(60000), num=100)<br>
sr.gain = 100<br>
sr.hpf = off<br>
sr.vpp = 4.096<br>
<br>
Sine run will:<br>
<ul>
  <li>set the channel, gain, and hpf, and raw mode</li>
  <li>set the ats mode, vpp</li>
  <li>runs, collects, saves data</li>
</ul>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
<br>
</body>
</html>
