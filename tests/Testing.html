<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="content-type">
  <title>Soma Acquisition Board Testing</title>
</head>
<body>
<span style="font-weight: bold; text-decoration: underline;">13 January
2004</span><br style="font-weight: bold; text-decoration: underline;">
<br style="font-weight: bold; text-decoration: underline;">
Okay, this is the assembly and testing log of our (*pray*) final
acquisition board. <br>
<br>
First, some last-minute component shopping:<br>
25LC320/SN-ND EEPROM<br>
SJ5523-0-ND Little rubber feet<br>
399-1091-ND extra bypass caps<br>
399-1096-ND extra bypass caps<br>
67-1253-ND RT &lt; dual LED, red<br>
240-1001-1-ND big analog supply ferrite<br>
240-1008-1-ND smt ferrite bead<br>
RR08P10.0KBCT-ND precision 10k resistors<br>
<br>
Now, testing plans:<br>
<br>
one board, just analog stuff -- no digital<br>
<br>
other board, just digial, no analog.<br>
<br>
<br>
Things to test:<br>
first, digital power supplies<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">14 January
2004</span><br style="font-weight: bold; text-decoration: underline;">
Okay, there's already some code in the "vhdl" subdirectory. Today, I'm
going to create LEDFLASH.vhd which will just flash the leds to let us
know things have booted correctly. <br>
<br>
Baah! After all this work, the vias on the lower right side of the
board didn't connect to the plane! I don't know why -- did I send them
the wrong gerbers? Is this a power plane issue? WTF?<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">9
Februrary 2004</span><br
 style="font-weight: bold; text-decoration: underline;">
After working on the DSP board and getting it + it's accompanying FPGA
code mostly done, we can return our focus to the Acqboard, the
make-or-break component of the system. <br>
<br>
First, Analog power system, which appears to work. <br>
<br>
<br>
Just the output of the AD8221, nothing else. Just A1. <br>
<br>
So, first, just going to solder up an AD8221 and see what we get. <br>
Please note that board 1 Channel A1 is using a 1.0% 475-ohm gain
resistor that measures 476 ohms. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">23
February 2004</span><br
 style="font-weight: bold; text-decoration: underline;">
We get what looks to be 150 uV P-P noise when shorting the inputs of
the A1 AD221 together, at g=104, would translate into &lt; 2 uV input
noise. Strangely, it also looks like we've got a roughly 1.5 uV input
Vos, which seems low. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">16 March
2004</span><br style="font-weight: bold; text-decoration: underline;">
Updated filter design<br>
corrected values to make second-stage 2nd-order LPF bessel with correct
<br>
values<br>
<br>
verified in SPICE<br>
<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">15 April
2004</span><br style="font-weight: bold; text-decoration: underline;">
isolators + shift registers appear to produce correct outputs for at
least a subset of the outputs (i.e. didn't test all)<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">17 April
2004</span><br style="font-weight: bold; text-decoration: underline;">
Discovered that the wrong packaging was used for the EEPROM -- TSSOP
and SOIC packages have different pinouts, and was using the TSSOP
pinout withthe SOIC package. Obviously, this won't work. Solved by
removing IC, soldering CS\ and SO pins together, so all values read
should be zero. This will prevent testing EEPROM reading, writing, on
this version of the acqboard, and will require us having loaden == 0.
Which sucks. But it will still let us measure a great deal of analog
performance. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">23 May 2004</span><br
 style="font-weight: bold; text-decoration: underline;">
Getting ready for tomorrow's testing and assembly. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">24 May 2004</span><br
 style="font-weight: bold; text-decoration: underline;">
Well, look who didn't remember to update the overlays. This really
sucks. So, pending the arrival of the jtag hardware today, we'll test
to make sure we can boot, but that's about it. <br>
<br>
Things wrong on the acqboard:<br>
Overlay text overlays some of the traces. <br>
The connector size for the jtag programmer is wrong. <br>
<br>
But, using 5k Ohm pullups for all pullups and 200 ohm current-limiting
resistors, we have things working. We can connect to the chain, program
the PROM, directly download via the jtag chain to the FPGA. I'd say
this jtag setup was a success. <br>
<br style="font-weight: bold; text-decoration: underline;">
<span style="font-weight: bold; text-decoration: underline;">30 May 2004</span><br
 style="font-weight: bold; text-decoration: underline;">
A short between VSS and GND on the analog side caused this board to be
a loss, but luckily I was able to test the DL capabilities, and sure
enough, the acqboard command interface appears to work correctly.
However, the code is fragile for a number of reasons, including (but
not limited to) <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">3 June 2004</span><br
 style="font-weight: bold; text-decoration: underline;">
Can successfully download, boot, read filters, sample buffer from
EEPROM, acqboard. Turns out there were problems with which exact bytes
we were reading with the loader. Note EEPROM needs you to wait the FULL
5 MS before you try another operation following a write. <br>
<br>
Mode 2 will only use channels 0, 4, and 8 for the sample buffer due to
the way in which we write them. <br>
<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">17 June
2004</span><br style="font-weight: bold; text-decoration: underline;">
So, the new connector size is correct, but the connectors we bought
don't have the correct notch and so in general don't fit. But the
bigger issue was that the solder mask expansion on the connector wasn't
large enough, thus scraping ,and the hole's werent' big enough, hence
drilling. The problem was the VCC and the GND connectors, which needed
jumpers. <br>
<br>
AS of now, things are booting. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">18 June
2004</span><br style="font-weight: bold; text-decoration: underline;">
Wow, mixed up OVDD and OGND pins on ADCs. I suck. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">1 July 2004</span><br
 style="font-weight: bold; text-decoration: underline;">
We can get sine data in raw mode. Now, I'm not sure why everything else
isn't working, and I'm also not sure why we evidently have this damn
jitter, but I'm going to write some analysis code today to look at it. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;"> 2 July
2004</span><br style="font-weight: bold; text-decoration: underline;">
Switching the inputs on the INPUT stage for A &amp; B, such that things
will behave like I expect them to. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">10 July
2004 </span><br style="font-weight: bold; text-decoration: underline;">
Today we begin writing the batch data collection code... we'll see if
this really works!<br>
<br>
<br>
<span style="font-weight: bold; text-decoration: underline;">14 July
2004</span><br style="font-weight: bold; text-decoration: underline;">
<br>
Initial tests show the second harmonic to be down by only 60 dB; I'm
not sure what's causing it, but I've devised a plan to check. We're
switching the test write-up to HTML and we're storing all data in HDF5.
<br>
<br>
The format will be as follows. We're doing all of this with <a
 href="http://pytables.sf.net">pytables</a> as a really nice interface.
Lovely, though, it appears pytables doesn't support storing of arrays
as attributes (metadata). So we use... strings!!!<br>
<br>
All files will have a "notes". We can also attach&nbsp; notes to each
channel. <br>
<br>
each file will have a channelname (A1, AC, etc) off the root, which
will be the data for that channel. In general, then, a file might have:<br>
<br>
/A1/sine/run0 <br>
/A1/sine/run1 <br>
/A2/noise/run0<br>
/A2/noise/run1<br>
/BC/IMD/run0<br>
/B1/real/run0<br>
<br>
The root will always have a "notes" field, as well as <br>
<br>
now, each "run" has the necessary metadata to fully describe both the
state of the acqboard and the function generator:<br>
Function generator:<br>
<br>
amplitude tuple of 2 floats (for IMD)<br>
frequency tuple of 2 floats (for IMD)<br>
mode (any of the noted modes, 0=sin, 1=sqr 2=white, 3=pink, 4=2tone)<br>
offset (float) <br>
<br>
Aqboard:<br>
mode (int)<br>
inchanA<br>
inchanB<br>
gains = tuple of 10 ints, as string<br>
hpfs = tuple of 10 ints, as string<br>
rawchan : raw channel<br>
<br>
<br>
Now, how to organize the code? <br>
<br>
Ideally, we do:<br>
create acqstate object<br>
create fstate object<br>
perform run, take data<br>
save as "location", acqstate, fstate<br>
<br>
really, all this code should live under "analysis"<br>
<br>
<br>
"test" handles interfacing with all the components and retrieving the
results<br>
<br>
"run" will handle putting the data in the relevant format for hdf5,
saving the results, etc. <br>
<br>
How to organize "runs"? what we really want is something that will just
DTRT given an acqstate and a function state, and a number of samples. <br>
<br>
So, a "run" could be a hdf5 wrap of a test. That wouldn't suck. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">15 July
2004</span><br style="font-weight: bold; text-decoration: underline;">
First, we want to run the pure sine test, using a coherently sampled
sine wave. Early tests suggest that we're not getting quite what we'd
hope for... so we've created this notion of "sets" of runs. <br>
<br>
<span style="font-weight: bold; color: rgb(0, 0, 102);">Generated
results/20040715/simplerun.h5 sweeping through gains, freqencies on the
first ADC, both inputs. </span><br
 style="font-weight: bold; color: rgb(0, 0, 102);">
<br>
<img style="width: 1200px; height: 900px;" alt=""
 src="results/20040715/simplerun.sine.g100.g0.a100.png"><br>
The above is the result of <span style="font-weight: bold;">channel A1
being fed a 207 Hz coherently-sampled sine, using a gain of 1 with
DC-based HPF</span>.&nbsp; Similarly, <br>
<br>
This isnt' the best way of visualizing this, I think I'm going to write
the "show" code to write parameters...<br>
<br>
Anywho, the results look similar across the board -- 76-77 dB of actual
SNR. <br>
<br>
Now, let's look at raw noise. <br>
<br>
The noise data is truly bizzare. All of what follows is from
rtinoise.h5. We get as-expected noise distributions for low gains on
channel A1:<br>
<br>
<img style="width: 600px; height: 450px;" alt=""
 src="results/20040715/rtinoise.A1.g100.png"><img
 style="width: 600px; height: 450px;" alt=""
 src="results/20040715/rtinoise.A2.g100.png"><img
 style="width: 600px; height: 450px;" alt=""
 src="results/20040715/rtinoise.A1.g10000.png"><img
 style="width: 600px; height: 450px;" alt=""
 src="results/20040715/rtinoise.A2.g10000.png"><br>
<br>
So, visually, the distributions for the high-gain outputs looks really
poor. I have no idea where the spiking is coming from, although there
are a few candidates:<br>
<ul>
  <li>external environment noise. Okay, maybe, but why the unusual
distribution? The spikes appear truly random in time, but clearly
quantized in amplitude. <br>
  </li>
  <li>They could potentially be bit-errors in the readout. But they
show up in powers of two. For example:</li>
</ul>
<div style="text-align: center;"><img
 style="width: 1200px; height: 900px;" alt=""
 src="results/20040715/rtinoise.A2.g10000.ranges.png"><br>
</div>
<br>
So hmm, that doesn't look suspicious?? But even if you assume errors in
bits 7 &amp; 8, WHY those bits and WHY only at high gains? This does
not make sense, at all! Perhaps the errors only manifest themselves
when the input is in that region? It can't be an 8b/10b related issue,
because that's a byte-encoding. The input-range hypothesis can be
tested. <br>
<br>
So, could we potentially have an error -any- place we have a 16-bit
interface? <br>
<br>
Wow, looking back, this is the histogram for the diff for the A1
channel with freq 1 at g=100 with 100% amplitude:<br>
<br>
<div style="text-align: center;"><img
 style="width: 1200px; height: 900px;" alt=""
 src="results/20040715/simplerun.A1.sine.g100.a100.hist-of-diff.png"><br>
<div style="text-align: left;">The red bars are at +-256 and +/- 512.
Wow, wow, Wow. <br>
<br>
An interesting idea would be to see what we can get out of the
simulated output mode. Inital inspections suggest nothing; maybe we
only get errors for certain ranges? Let's program the sample buffer for
a 0-255 sweep...<br>
<br>
<br>
<br>
Well, after investigating a bit more, there is some sever strangeness
occuring with the sample buffer mode. I don't quite understand what's
going on. In any case, that's a day!!<br>
<br>
</div>
</div>
<br>
<span style="font-weight: bold; text-decoration: underline;">16 July
2004</span><br style="font-weight: bold; text-decoration: underline;">
Now, it seems that the sample input is having problems -- let's see
what's up!<br>
<br>
THE OUTPUT VALUES GO FROM 0 to 248 BECAUSE IT IS DOWNSAMPLING THE
OUTPUT! YOU FOOL!<br>
<br>
When we run with a random sequence of inputs, we don't have problems --
we read out a reasonably random range between -32768 and 32768, without
error. <br>
<br>
The thing is, this just -really- looks like an ADC problem -- I can't
think of anything else it might be!<br>
<br>
Channel modifications<br>
<ul>
  <li>A3 has connected the output of the inamp to the input of the AA
filter<br>
  </li>
  <li>A4 is shorts the input of the AA filter to nearby ground</li>
</ul>
So, we're still getting the noise problems (see
results/date/rtinoise.modified), so we took the board and resoldered
around the ADC. One pin on the A1/2 ADC wasn't soldered correctly. <br>
<br>
So, having soldered, now we'll take more data. And we get outputs (from
results/data/rtinoise.modified.post-solder) like:<br>
<br>
<img style="width: 1200px; height: 900px;" alt=""
 src="results/20040716/rtinoise.modified.post-solder.A3.g100.png"><br>
<br>
Which, umm, is crap. Look at that!!! Smilarly, for A1:<br>
<img style="width: 1200px; height: 900px;" alt=""
 src="results/20040716/rtinoise.modified.post-solder.A1.g10000.png"><br>
<br>
So, here we are, the same place we were yesterday, but with more
inputs. I really have no freaking idea what to do. <br>
<br>
While out at dinner, came up with a few small ideas. First, per-bit
statistics: mean, variance, distribution.<br>
<br>
Bit statistics appear to tell us nothing unusual. But look at this:<br>
<br>
<img style="width: 512px; height: 384px;" alt=""
 src="results/20040716/a2.g10000.diff.hist.png">This is a histogram of
the differences from the full record of A2. Wow, it sure does look
like, say, 255 is getting randomly added or subtracted there!! But
where? where is this coming from? ADC errors? <br>
<br>
Even on the sine data! Here's yesterday's sine recording, but a plot of
the diff() of the signal!<br>
<br>
<img style="width: 1200px; height: 900px;" alt=""
 src="results/20040716/sinediffs.png"><br>
<br>
Again, how horrible!! We're running out of potential candidates. Now,
it -could- be a problem internal to the FPGA, but that's just so
unlikely that I'm not even going to consider it. Although the above
suggests either an -amplitude- or -phase- correlation. But rather than
hyper-analyzing it, let's figure out our timings again. The only
plausable candidate at the moment is the isolators, although I'll be
damned if I can figure out how they'd cause -this- sort of error. <br>
<br>
Measuring on the scope, a SDOUT bit width is ~50 ns, which, when you
sum the worst-case propagation times for the various components in the
chain, "might" be an issue. Except that measuring the propagation
delays of various bits of the system with the scope suggests that we're
really looking at a P(delay) of, oh, 10 ns -total-. The ADC seems to be
pretty good at sticking with 2 ns. At the same time, the sorts of
single-bit errors (why always the same place) suggests a real
fundamental problem. <br>
<br>
On a slight hunch (yikes!) I'm going to try and sample one cycle
earlier. <br>
<br>
Umm, that appears to have made things worse! Sampling one cycle sooner
(INCE one cycle ahead) gives... <br>
<img style="width: 1200px; height: 900px;" alt=""
 src="results/20040716/early-cycle.sinediffs.png"><br>
<br>
At least this strongly suggests what the real problem is. The downside
is how to work around it -- how can we possibly hope to speed things up
at all? <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">17 July
2004</span><br style="font-weight: bold; text-decoration: underline;">
<br>
Okay, new day, new calculations. Currently we allow for 139 ticks (2.17
us) between CONVST assertion and when we start reading. That's way too
long. Really, we could go to 112 ticks and be fine. Maybe even 120 to
compensate for propagation delay. Alas, even after adding the extra
cycle, we're still getting the same errors, although perhaps the DL to
the board didn't go correctly? <br>
<br>
So we reverted to the original input code and made a simulation of the
inputs.. no problems. Ass. Even when we have raw mode disable the
offsets, we're still getting the errors. <br>
<br>
Simulations seem to suggest that we can endure aggregate propagation
delays of 44 ns between when we actually output SCLK and when we get
the result. <br>
<br>
There appears to be a dependence on the amplitude here. <br>
<br>
Rapidly running out of ideas, fish found some unsoldered bypass caps
and soldered them, with no result. Similarly, I've changed the ADCIN
inputs on the FPGA to use internal pull-downs. Again, no luck. What
about a pull-down on the analog side of the IO converter? Still no
difference. At this point, I'm willing to say that the sticky bits
hypothesis has no real luck of going anywhere. <br>
<br>
Okay, there are two types of problems: those I can fix and those I
can't. Those I can't fix fall into<br>
<ul>
  <li>Something wrong with the ADC:</li>
  <ul>
    <li>it just sucks, and you're SOL</li>
    <li>There's some problem related to the reference</li>
    <li>there's some problem related to the internal converter</li>
    <li>there's some problem related to the input</li>
  </ul>
  <li>Something's wrong with the GMR Isolators</li>
  <ul>
    <li>You just can't drive them this way, i.e. they get stuck
sometimes and there's just nothing you can do about it</li>
  </ul>
</ul>
<br>
Moving INEN to the SCLKH1 line hasn't accomplished anything... I feel
like I'm going about this all wrong... <br>
<br>
<br>
When I intentionally read too few bits, I get the following from
channel A1:<br>
<img style="width: 600px; height: 450px;" alt=""
 src="results/20040717/intentional-bit-error.png"><br>
This, while pretty, is -not- what we're getting, although it -does-
look somewhat familiar. A2 looks near-identical. Frustration, coupled
with near-insanity, is forcing me to ditch the output registers, and
just focus on a simple interface with no output registers. Yea, we
could have glitches on the output (although how likely is this?) but
... it simplifies things tremendously. <br>
<br>
<table style="text-align: left; width: 255px; height: 74px;" border="1"
 cellspacing="2" cellpadding="2">
  <tbody>
    <tr>
      <td style="vertical-align: top;">SCLK out of FPGA<br>
      </td>
      <td style="vertical-align: top;">4 ns<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">cross 1st ISO<br>
      </td>
      <td style="vertical-align: top;">15 ns<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">SCLK to SDOUT<br>
      </td>
      <td style="vertical-align: top;">18 ns<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">cross second ISO <br>
      </td>
      <td style="vertical-align: top;">18 ns<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">into FPGA<br>
      </td>
      <td style="vertical-align: top;">4 ns<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top;">setup<br>
      </td>
      <td style="vertical-align: top;">2 ns<br>
      </td>
    </tr>
    <tr>
      <td style="vertical-align: top; font-weight: bold;">TOTAL<br>
      </td>
      <td style="vertical-align: top; font-weight: bold;">61 ns<br>
      </td>
    </tr>
  </tbody>
</table>
<br>
<br>
For comparison, the full 4 cycle setup will take... 62.5 ns!!!<br>
<br>
WEll, I re-wrote the input code for the ADCs, taking out the pipelining
(but also removing some of the registering -- whatever) and I'm excited
that I can hopefully eliminate it as a potential issue. But still...
same errors. <br>
<br>
<span style="font-weight: bold; text-decoration: underline;">18 July
2004</span><br style="font-weight: bold; text-decoration: underline;">
Wow, rapidly running out of ideas. The fixed ADC code hasn't helped
any. I still get the quantization, even when I directly connect the
unbalanced output of the function generator into the input of the ADC. <br>
<br>
Watching the output on the scope, we can see that all output values are
being set. This can be seen by triggering off of CS and taking the
average; any stuck value would be apparent. We see the same thing on
the other side of the FPGA. Even having the FPGA latch bits suggests --
there's no bit sticking!<br>
<br>
<br>
In an attempt to re-evaluate where we are, I'm going to re-acquire a
sample. <br>
<br>
Indeed, results/today/sineagain.h5 shows A1.g100.f1.a100 to be nearly
the same as above, with the same problems. Let's look at the hist of
the diffs...<br>
<br>
<img style="width: 600px; height: 450px;" alt=""
 src="results/20040718/a1.g100.f0.a100.diff-hist.png"><img
 style="width: 600px; height: 450px;" alt=""
 src="results/20040718/a1.g100.f0.a100.diff-hist-zoom.png"><br>
<br>
Now, the diff histogram is similar to earlier (pre- New Input.vhd)
data, but the odd multiples of 8 never showing up as diffs is totally
an error. <br>
<img style="width: 600px; height: 450px;" alt=""
 src="results/20040718/sineagain.a1.mod16.png"><br>
Interestingly, A3 &amp; A4 don't have this problem -- maybe it has to
do with the pull-up resistor? Cutting resistor and rerunning...<br>
<br>
Nope, still the same problem. Here's a bit-plot:<br>
<br>
<br>
<br>
<br>
<img style="width: 1200px; height: 900px;" alt=""
 src="results/20040718/samebits.png"><br>
This is for A1, g=100, data taken from sine_noresistor.h5. Both A1 and
A2 exhibit this problem, but A3 does not. But <span
 style="font-style: italic;">the shifted outputs of the ADC (as
measured by averaging) don't appear to have this problem!<span
 style="font-weight: bold;"> </span></span>In fact, both bits 2 and 3
appear to be unaffected. This is now super-duper odd, esp. since it
only affects ADC1. <br>
<br>
Went down, made timing constraints a bit tighter on CLK, and switched
all input voltage levels to LVTTL. Didn't help with -either- problem;
A1/2 still shows identical bits 2 &amp; 3; both ADCs 1 &amp; 2 still
have 256 problems. <br>
<br>
<br>
Now we get desperate: we're going to trash the input stage. Make it as
simple as possible; all we'll get out is the input of chan 0 <br>
<br>
<span style="font-weight: bold;">Then I tried to totally rewrite the
input code</span> to just do a quick hack, but I -still- get the 256
errors. BUT that fixed the 2/3 bit stick error. Grrr. <br>
<br>
This does not make sense. <br>
<br>
<br>
<br>
<br>
</body>
</html>
